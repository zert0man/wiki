# Cheat-list PHP

## Краткое описание

Синтаксис PHP подобен синтаксису языка Си. Некоторые элементы, такие как ассоциативные массивы и цикл foreach, заимствованы из Perl.

Для работы программы не требуется описывать какие-либо переменные, используемые модули и т. п. Любая программа может начинаться непосредственно с оператора PHP.

Простейшая программа Hello world на PHP выглядит следующим образом:
```
<?php
  echo 'Hello, world!'; 
?>
```

PHP исполняет код, находящийся внутри ограничителей `<?php ?>`. Всё, что находится вне ограничителей, выводится в http-ответ без изменений. В основном это используется для вставки PHP-кода в HTML-документ, например, так:

```
<html>
 <head>
  <title>Тестируем PHP</title>
 </head>
 <body>
  <?php echo 'Hello, world!'; ?>
 </body>
</html>
```

Имена переменных начинаются с символа `$`, тип переменной объявлять не нужно. Имена переменных, функций и классов чувствительны к регистру. Константы также чувствительны к регистру. 

PHP рассматривает переход на новую строку как пробел, так же как HTML и другие языки со свободным форматом. Инструкции разделяются с помощью точки с запятой (`;`) по правилам очень близким к языку Си (есть несколько исключений, но если вы ставите точку с запятой как в Си, то проблем не будет).

Переменные в функцию можно передавать как по значению, так и по ссылке (используется знак &).

PHP поддерживает три типа комментариев: в стиле языка Си (ограниченные `/* */`), C++ (начинающиеся с `//` и идущие до конца строки) и оболочки UNIX (с `#` до конца строки).

## Типы данных
PHP является языком программирования с динамической типизацией, не требующим указания типа при объявлении переменных, равно как и самого объявления переменных. Преобразования между скалярными типами зачастую осуществляются неявно без дополнительных усилий (впрочем, PHP предоставляет широкие возможности и для явного преобразования типов).

К скалярным типам данных относятся:

-     целый тип (`integer`),
-   вещественный тип данных (`float, double`),
-   логический тип (`boolean`),
-   строковый тип (`string`),
-   специальный тип `NULL`.

К нескалярным типам относятся:

-    <<ресурс>> (`resource`),
-  массив (`array`),
-  объект (`object`),

К псевдотипам относятся:

	- `mixed` один или несколько необязательных параметров,
  -   `number` число (`integer` либо `float`)
  -   `callback` (`string` или анонимная функция)
  -  `void` отсутствие параметров


Диапазон целых чисел (`integer`) в PHP зависит от платформы (обычно, это диапазон 32-битных знаковых целых чисел, то есть, от -2 147 483 648 до 2 147 483 647). Числа можно задавать в десятичной, восьмеричной и шестнадцатеричной системах счисления. Диапазон вещественных чисел (`double`) также зависит от платформы (для 32-битной архитектуры диапазон позволяет оперировать числами от ±1.7?10-308 до ±1.7?10+308).

PHP предоставляет разработчикам логический тип (`boolean`), способный принимать только два значения TRUE («истина») и FALSE («ложь»). При преобразовании в логический тип число 0, пустая строка, ноль в строке «0», NULL и пустой массив считаются равными FALSE. Все остальные значения автоматически преобразуются в TRUE.

Специальный тип NULL предназначен для переменных без определенного значения. Единственным значением данного типа является константа NULL. Тип NULL принимают неинициализированные переменные, переменные инициализированные константой NULL, а также переменные, удаленные при помощи конструкции `unset()`.

Строки могут заключаться в одинарные или в двойные кавычки. Если строка в двойных кавычках, то непосредственно в ней можно указывать переменные, и вместо переменной будет вставлено ее значение. Поэтому строки в двойных кавычках обрабатываются медленнее, чем в одинарных. Конкатенация строк осуществляется с помощью операции "."">. С помощью этого оператора можно собрать строку из нескольких элементов различных типов (числа автоматически переводятся в строки, у объектов вызывается метод `toString()`).

Ссылки на внешние ресурсы имеют тип «ресурс» (`resource`). Переменные данного типа, как правило, представляют собой дескриптор, позволяющий управлять внешними объектами, такими как файлы, динамические изображения, результирующие таблицы базы данных и т. п.

Массивы (`array`) поддерживают числовые и строковые ключи и являются гетерогенными. Массивы могут содержать значения любых типов, включая другие массивы. Порядок элементов и их ключей сохраняется. Не совсем корректно называть php-массивы массивами, на самом деле это, скорее всего, упорядоченный хеш. Возможно неожиданное поведение при использовании цикла `for` со счетчиком вместо `foreach`. Так, например, при сортировке массива с численными индексами функциями из стандартной библиотеки, сортируются и ключи тоже.

Указатель на функцию в PHP может быть представлен замыканием или псевдотипом `callback`. Замыкание доступно с версии 5.3 и в коде выглядит как простое определение функции, в которую явно можно утянуть значения из контекста, например:
```
 function($args..$argsN) use($ctxVar,$ctxVar1) { definition ; }
```

Для проверки является ли значение вызываемым следует использовать `is_callable($var)`.

##Обращение к переменным и функциям

Обращение к переменным осуществляется с помощью символа `$}, за которым следует имя переменной. Данная конструкция может быть применена также для создания динамических переменных и функций. Например:
```
$a = 'I am a'; // Запись значения в переменную $a
echo $a; // Вывод переменной $а
 
$b = 'a';
echo $$b; // Вывод переменной $а (дополнительный $ перед переменной $b)
 
echo ${'a'}; // Вывод переменной $a
 
function_name(); // Вызов функции function_name
$c = 'function_name';
$c(); // Вызов функции function_name,
 
$d = 'Class_name';
$obj = new Class_name; // Создание объекта класса Class_name
$obj = new $d(); // Создание объекта класса Class_name
 
$obj->b; // Обращение к полю b объекта
$obj->c(); // Вызов метода c() объекта
 
$obj->$b; // Обращение к полю a объекта, так как $b = 'a'
$obj->$c(); // Вызов метода function_name() объекта, так как $c = 'function_name'
```

В PHP `echo` и `print` не являются функциями (хотя `print` имеет возвращаемое значение), а являются синтаксическими единицами. При их использовании можно опустить скобки.

##Суперглобальные массивы

Суперглобальными массивами в PHP называются предопределенные массивы, имеющие глобальную область видимости без использования директивы global. Большая часть этих массивов содержит входные данные запроса пользователя (параметры GET-запроса, поля форм при посылке методом POST, куки и т. п.).

Все суперглобальные массивы, кроме `$GLOBALS` и `$_REQUEST`, имеют устаревшие аналоги с длинными именами, которые доступны вплоть до версии 5.3.х (начиная с 5.4.0 были удалены). Таким образом, обращения `$_GET['year']` и `$HTTP_GET_VARS['year']` идентичны (за исключением области видимости: массивы с «длинными» именами не являются суперглобальными).

`$GLOBALS`
    Массив всех глобальных переменных (в том числе и пользовательских).

`$_SERVER` (устаревший аналог - `$HTTP_SERVER_VARS`)
    Содержит переменные окружения, которые операционная система передает серверу.

`$_ENV` 
    Текущие переменные среды. Их набор специфичен для платформы, на которой выполняется скрипт.

`$_GET` 
    Содержит параметры GET-запроса, переданные в URI после знака вопроса <<?>>.

`$_POST` 
    Ассоциативный массив значений полей HTML-формы при отправке методом POST. Индексы элементов соответствуют значению свойства name объектов(кнопки, формы, радио-кнопки, флажки и т.д.) HTML-формы.

`$_FILES `
    Ассоциативный массив со сведениями об отправленных методом POST файлах. Каждый элемент имеет индекс, идентичный значению атрибута «name» в форме, и, в свою очередь, также является массивом со следующими элементами:

			 -    `['name']` - исходное имя файла на компьютере пользователя.
		-				`['type']` - указанный агентом пользователя MIME-тип файла. PHP не проверяет его, и поэтому нет никаких гарантий, что указанный тип соответствует действительности.
      -  `['size']` - размер файла в байтах.
     -   `['tmp_name']` - полный путь к файлу во временной папке. Файл необходимо переместить оттуда функцией `move_uploaded_file}. Загруженные файлы из временной папки PHP удаляет самостоятельно.
      -  `['error']` - код ошибки. Если файл удачно загрузился, то этот элемент будет равен 0 (`UPLOAD_ERR_OK}).


`$_COOKIE` 
    Ассоциативный массив с переданными агентом пользователя значениями куки.

`$_REQUEST`
    Содержит элементы из массивов `$_GET`, `$_POST`, `$_COOKIE`. С версии PHP 4.1 включает `$_FILES`.

`$_SESSION` 
    Содержит данные сессии.

##Объектно-ориентированное программирование

PHP поддерживает широкие объектно-ориентированные возможности, полная поддержка которых была введена в пятой версии языка.

Класс в PHP объявляется с помощью ключевого слова `class`. Методы и поля класса могут быть общедоступными (`public`, по умолчанию), защищенными (`protected`) и скрытыми (`private`). PHP поддерживает все три основных механизма ООП - инкапсуляцию, полиморфизм и наследование (родительский класс указывается с помощью ключевого слова `extends` после имени класса). Поддерживаются интерфейсы (ставятся в соответствие с помощью `implements`). Разрешается объявление финальных, абстрактных методов и классов. Множественное наследование классов не поддерживается, однако класс может реализовывать несколько интерфейсов. Для обращения к методам родительского класса используется ключевое слово `parent`.

Классы в PHP имеют ряд специальных методов (magic methods), начинающихся с двух символов подчеркивания. Особо стоит отметить конструктор (`__construct()`, в версиях до 5.0 конструктором служил метод, одноименный с классом) и деструктор (__destruct()), а также методы чтения (`__get()`) и записи (`__set()`) и др. Эти методы являются достаточно гибким инструментом: переопределяя их, можно добиться существенного изменения поведения объекта.

Экземпляры класса создаются с помощью ключевого слова new, обращение к полям и методам объекта производится с использованием оператора `->`. Для доступа к членам класса из его методов используется переменная `$this`.
```
class C1 extends C2 implements I1, I2
{
  private $a;
  protected $b;
 
  function __construct($a, $b)
  {
    parent::__construct($a, $b);
    $this->a = $a;
    $this->b = $b;
  }
 
  public function plus()
  {
    return $this->a + $this->b;
  }
/* ............... */
}
 
$d = new C1(1, 2);
echo $d->plus(); // 3
```

Начиная с пятой версии PHP, объекты передаются по ссылке:
```
class a 
{
  public $color = 'red';
}
 
$a = new a();
echo $a -> color; // red
$b = $a;
$b -> color = 'blue';
echo $a -> color; // blue
```

```
<?php
class MyClass {
  const CONST_VALUE = 'Значение константы';
}
// Использование :: вне объявления класса
echo MyClass::CONST_VALUE;
?>

```

## Сслыка на документацию