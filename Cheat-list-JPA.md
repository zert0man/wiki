# Java Persistence Api

**Java Persistence Api** - это один из классических способов реализации уровня абстракции данных в Java.

**Entity (Сущность)** - класс, связанный с БД с помощью аннотации (`@Entity`) или через XML. К такому классу предъявляются следующие требования:
- должен иметь пустой конструктор (`public` или `protected`);
- не может быть вложенным, интерфейсом или `enum`;
- не может быть final и не может содержать `final`-полей/свойств;
- должен содержать хотя бы одно `@Id`-поле.

При этом сущность может:
- содержать непустые конструкторы;
- наследоваться и быть наследованным;
- содержать другие методы и реализовывать интерфейсы.

Сущности могут быть связаны друг с другом.

[Документация по JPA-аннотациям](http://www.oracle.com/technetwork/middleware/ias/toplink-jpa-annotations-096251.html)

[Документация по методам репозиториев Spring Data JPA](http://docs.spring.io/spring-data/jpa/docs/1.6.5.RELEASE/reference/html/jpa.repositories.html)

## Аннотации описания таблиц

`@Entity` сообщает фреймворку, что данный класс используется как класс сущности. Пишется перед определением класса.

`@Table(foo)` конфигурирует имя таблицы, в которой будет храниться сущность (в данном случае имя таблицы `foo`).

`@Id` указывайте перед полями класса, которые создают первичный ключ таблицы. Классический пример:

```
    @Id
    private int ID;
```

Если вы хотите создать составной ключ, используйте `@IdClass` или `@EmbeddedId`.


`@Column` используется для задания свойств хранения отдельных полей сущности в таблице:

```
@Column(nullable = false, unique = true)
private String name;
```

## Аннотации описания связей

Аннотации `@OneToOne`, `@ManyToOne`, `@OneToMany`, `@ManyToMany` используются для описания связей между сущностями.

Пример:

```
	@OneToMany(mappedBy = "id.student", cascade = CascadeType.REMOVE)
	private Collection<Score> scores;
``

## Аннотации описания событий
JPA позволяет задать функции для обработки собылий в классе сущности:
- `@PrePersist` - перед сохранением сущности в базу;
- `@PostPersist` - после сохранения сущности;
- `@PreRemove` - перед удалением записи;
- `@PostRemove` - после удаления записи;
- `@PreUpdate` - перед обновлением записи;
- `@PostUpdate` - после обновления записи.

## Репозитории Spring Data JPA 

В Spring для работы с базой данных используется специальный вид компонентов - репозитории. Это интерфейсы, расширяющие класс `JpaRepository<EntityClass, EntityIdClass>`. 

Кроме набора стандартных методов (например, `findAll`) вы можете получить довольно сложные запросы, используя генерируемые методы. Например, метод `findByAgeOrderByLastnameDesc` будет искато по полю `age` (значение должно быть передано в параметрах) и сортировать по убыванию по полю `lastname`. **Вам достаточно описать такой метод в вашем интерфейсе репозитория. Код писать не надо, Spring Data сгенерирует его автоматически!** Все ключевые слвоа для создания таких методов описаны в документации. 

[Документация по методам репозиториев Spring Data JPA](http://docs.spring.io/spring-data/jpa/docs/1.6.5.RELEASE/reference/html/jpa.repositories.html)